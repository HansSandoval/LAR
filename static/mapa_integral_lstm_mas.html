<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema Integral: LSTM + MAS + VRP</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #map { position: absolute; top: 0; bottom: 0; width: 100%; }
        
        .panel {
            position: absolute;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 20px;
            z-index: 1000;
        }
        
        .panel-config {
            top: 20px;
            right: 20px;
            width: 350px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .panel-stats {
            bottom: 20px;
            left: 20px;
            width: 300px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        h2 { 
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        
        h3 {
            color: #34495e;
            margin: 15px 0 10px 0;
            font-size: 14px;
            font-weight: 600;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-size: 13px;
            font-weight: 500;
        }
        
        input[type="number"],
        input[type="date"],
        select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: #3498db;
        }
        
        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 10px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
        }
        
        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(56, 239, 125, 0.4);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
            color: white;
        }
        
        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(235, 51, 73, 0.4);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }
        
        .stat-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        
        .stat-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-box.green {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }
        
        .stat-box.blue {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }
        
        .stat-box.orange {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }
        
        .stat-value {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 11px;
            opacity: 0.9;
            text-transform: uppercase;
        }
        
        .alert {
            padding: 12px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 13px;
        }
        
        .alert-info {
            background: #e3f2fd;
            color: #1565c0;
            border-left: 4px solid #1976d2;
        }
        
        .alert-success {
            background: #e8f5e9;
            color: #2e7d32;
            border-left: 4px solid #4caf50;
        }
        
        .alert-warning {
            background: #fff3e0;
            color: #ef6c00;
            border-left: 4px solid #ff9800;
        }
        
        .legend {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 12px;
        }
        
        .legend-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid #333;
        }
        
        .truck-list {
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .truck-item {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 8px;
            border-left: 4px solid #3498db;
        }
        
        .truck-item strong {
            color: #2c3e50;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .loading {
            animation: pulse 1.5s infinite;
        }

        /* Estilos para notificaciones Toast */
        #toast-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }
        
        .toast {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            animation: slideIn 0.3s ease-out, fadeOut 0.5s ease-in 4.5s forwards;
            display: flex;
            align-items: center;
            gap: 10px;
            border-left: 4px solid #3498db;
        }
        
        .toast.negociacion {
            border-left-color: #f1c40f; /* Amarillo para negociaci√≥n */
            background: rgba(44, 62, 80, 0.9);
        }
        
        @keyframes slideIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="toast-container"></div>
    
    <!-- Panel de Configuraci√≥n -->
    <div class="panel panel-config">
        <h2>Sistema Integral de Recolecci√≥n</h2>
        
        <div class="alert alert-info">
            <strong>Paso 1:</strong> Selecciona fecha y carga predicciones LSTM
        </div>
        
        <h3>1. Predicciones LSTM</h3>
        <div class="form-group">
            <label for="fechaPrediccion">Fecha de Recolecci√≥n:</label>
            <input type="date" id="fechaPrediccion">
        </div>
        
        <button class="btn btn-primary" onclick="cargarPredicciones()">
            Cargar Puntos de Basura
        </button>
        
        <div id="estadoPredicciones"></div>
        
        <h3>2. Configuraci√≥n de Camiones</h3>
        <div class="form-group">
            <label for="numCamiones">N√∫mero de Camiones:</label>
            <input type="number" id="numCamiones" value="3" min="1" max="10">
        </div>
        
        <div class="form-group">
            <label for="capacidadCamion">Capacidad por Cami√≥n (kg):</label>
            <input type="number" id="capacidadCamion" value="3500" min="1000" max="10000" step="100">
        </div>
        
        <button class="btn btn-success" id="btnIniciar" onclick="iniciarSimulacion()" disabled>
            Iniciar Simulaci√≥n
        </button>
        
        <button class="btn btn-danger" id="btnDetener" onclick="detenerSimulacion()" disabled>
            Detener Simulaci√≥n
        </button>

        <button class="btn btn-primary" id="btnGuardar" onclick="guardarSimulacion()" disabled style="margin-top: 10px; background: #8e44ad;">
            üíæ Guardar Rutas Planificadas
        </button>
        
        <div id="estadoSimulacion"></div>
        
        <div class="legend">
            <h3>Leyenda</h3>
            <div class="legend-item">
                <div class="legend-icon" style="background: #2ecc71;"></div>
                <span>Baja (< 80 kg)</span>
            </div>
            <div class="legend-item">
                <div class="legend-icon" style="background: #f39c12;"></div>
                <span>Media (80-120 kg)</span>
            </div>
            <div class="legend-item">
                <div class="legend-icon" style="background: #e74c3c;"></div>
                <span>Alta (> 120 kg)</span>
            </div>
            <div class="legend-item">
                <div class="legend-icon" style="background: #3498db;"></div>
                <span>Vertedero</span>
            </div>
            <div class="legend-item">
                <div class="legend-icon" style="background: #8e44ad;"></div>
                <span>Base Operaciones</span>
            </div>
        </div>
    </div>
    
    <!-- Panel de Estad√≠sticas -->
    <div class="panel panel-stats">
        <h2>Estad√≠sticas en Tiempo Real</h2>
        
        <div class="stat-grid">
            <div class="stat-box green">
                <div class="stat-value" id="kgRecolectados">0</div>
                <div class="stat-label">KG Recolectados</div>
            </div>
            <div class="stat-box blue">
                <div class="stat-value" id="puntosServidos">0/0</div>
                <div class="stat-label">Puntos Servidos</div>
            </div>
            <div class="stat-box orange">
                <div class="stat-value" id="tiempoTotal">00:00</div>
                <div class="stat-label">Tiempo Total</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="paso">0</div>
                <div class="stat-label">Paso Actual</div>
            </div>
        </div>
        
        <h3>Estado de Camiones</h3>
        <div class="truck-list" id="listaCamiones">
            <p style="color: #999; font-size: 12px;">Inicia la simulaci√≥n para ver camiones</p>
        </div>

        <h3>Bit√°cora de Eventos</h3>
        <div class="log-container" id="bitacoraMensajes" style="max-height: 150px; overflow-y: auto; font-size: 11px; background: #f8f9fa; padding: 5px; border-radius: 5px; border: 1px solid #eee;">
            <p style="color: #ccc; margin: 0;">Esperando eventos...</p>
        </div>
    </div>
    
    <script>
        // ==================== VARIABLES GLOBALES ====================
        // Centrar mapa entre Base y Vertedero
        const map = L.map('map').setView([-20.245, -70.09], 13);
        let simulacionId = null;
        let intervalId = null;
        let timeoutId = null; // Nuevo: para control de ciclo secuencial
        let isFetching = false; // Flag para evitar solapamiento de peticiones
        let prediccionesActuales = [];
        let marcadoresPuntos = [];
        let marcadoresCamiones = [];
        let lineasRutas = [];
        let rastrosCamiones = [];  // Rastros permanentes de cada cami√≥n (l√≠nea s√≥lida del recorrido)
        let ultimaPosicionCamiones = {};  // √öltima posici√≥n conocida para animar
        
        // ==================== INICIALIZAR MAPA ====================
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors',
            maxZoom: 19
        }).addTo(map);
        
        // C√≠rculo de cobertura
        L.circle([-20.2666, -70.1300], {
            color: '#3498db',
            fillColor: '#3498db',
            fillOpacity: 0.1,
            radius: 5000,
            weight: 2
        }).addTo(map);
        
        // --- MARCADORES INICIALES (Base y Vertedero) ---
        
        // 1. Base de Operaciones (Inicio)
        const baseMarker = L.marker([-20.29305111963256, -70.12295105323292], {
            icon: L.divIcon({
                className: 'base-icon',
                html: '<div style="background: #8e44ad; width: 30px; height: 30px; border-radius: 5px; border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3); display:flex; justify-content:center; align-items:center; color:white; font-weight:bold;">B</div>',
                iconSize: [30, 30]
            })
        }).bindPopup('<b>Base de Operaciones</b><br>Inicio/Fin de Turno').addTo(map);

        // 2. Vertedero (Depot/Descarga)
        const vertederoMarker = L.marker([-20.19767564535899, -70.06207963576485], {
            icon: L.divIcon({
                className: 'depot-icon',
                html: '<div style="background: #3498db; width: 30px; height: 30px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                iconSize: [30, 30]
            })
        }).bindPopup('<b>Vertedero</b><br>Punto de Disposici√≥n Final').addTo(map);
        
        // ==================== FECHA POR DEFECTO ====================
        const ma√±ana = new Date();
        ma√±ana.setDate(ma√±ana.getDate() + 1);
        document.getElementById('fechaPrediccion').valueAsDate = ma√±ana;
        
        // ==================== FUNCI√ìN: CARGAR PREDICCIONES ====================
        async function cargarPredicciones() {
            const fecha = document.getElementById('fechaPrediccion').value;
            const estadoDiv = document.getElementById('estadoPredicciones');
            
            if (!fecha) {
                estadoDiv.innerHTML = '<div class="alert alert-warning">Por favor selecciona una fecha</div>';
                return;
            }
            
            estadoDiv.innerHTML = '<div class="alert alert-info loading">Cargando predicciones LSTM... (esto puede tardar 10-15 segundos)</div>';
            
            try {
                console.log(`üîç Solicitando predicciones para fecha: ${fecha}`);
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000); // 60 segundos timeout
                
                const response = await fetch(`/api/lstm/predicciones-fecha?fecha=${fecha}`, {
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                
                console.log(`‚úÖ Respuesta recibida: ${response.status}`);
                
                if (!response.ok) {
                    throw new Error(`Error HTTP: ${response.status}`);
                }
                
                const data = await response.json();
                console.log(`üìä Predicciones recibidas: ${data.predicciones?.length || 0} puntos`);
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                // Limpiar marcadores anteriores
                marcadoresPuntos.forEach(m => map.removeLayer(m));
                marcadoresPuntos = [];
                
                // Agregar campo 'servido' a cada predicci√≥n
                prediccionesActuales = (data.predicciones || []).map(pred => ({
                    ...pred,
                    servido: false,
                    id_punto: pred.punto // Usar nombre del punto como ID
                }));
                
                // Agregar nuevos marcadores
                prediccionesActuales.forEach((pred, idx) => {
                    const color = getColorPorDemanda(pred.prediccion_kg);
                    const radio = getRadioPorDemanda(pred.prediccion_kg);
                    
                    // Asignar ID correcto (usamos el ID que viene del backend si existe, o generamos uno secuencial 0..N-1)
                    // IMPORTANTE: El backend ahora retorna √≠ndices 0..N-1 en 'clientes_servidos_ids'
                    const idSimulacion = idx; 
                    
                    const marker = L.circleMarker([pred.latitud, pred.longitud], {
                        radius: radio,
                        fillColor: color,
                        color: '#333',
                        weight: 2,
                        opacity: 1,
                        fillOpacity: 0.7,
                        custom_id: idSimulacion, // ID temporal
                        nombre: pred.punto // Guardar nombre para sincronizaci√≥n
                    }).bindPopup(`
                        <div style="min-width: 200px;">
                            <h4 style="margin: 0 0 10px 0; color: ${color};">${pred.punto} (ID: ${idSimulacion})</h4>
                            <p style="margin: 5px 0;">
                                <b>Predicci√≥n:</b> <span style="color: ${color}; font-size: 16px; font-weight: bold;">
                                    ${pred.prediccion_kg.toFixed(0)} kg
                                </span><br>
                                <b>Fecha:</b> ${pred.fecha}<br>
                                <b>Coordenadas:</b> ${pred.latitud.toFixed(4)}, ${pred.longitud.toFixed(4)}
                            </p>
                        </div>
                    `).addTo(map);
                    
                    marcadoresPuntos.push(marker);
                });
                
                estadoDiv.innerHTML = `<div class="alert alert-success">
                    <strong>Listo!</strong> ${prediccionesActuales.length} puntos de recolecci√≥n cargados<br>
                    <small>Total estimado: ${prediccionesActuales.reduce((sum, p) => sum + p.prediccion_kg, 0).toFixed(0)} kg</small>
                </div>`;
                
                document.getElementById('btnIniciar').disabled = false;
                
            } catch (error) {
                console.error('Error:', error);
                estadoDiv.innerHTML = `<div class="alert alert-warning">
                    <strong>Advertencia:</strong> ${error.message}<br>
                    <small>Usando datos sint√©ticos...</small>
                </div>`;
                document.getElementById('btnIniciar').disabled = false;
            }
        }
        
        // ==================== FUNCI√ìN: INICIAR SIMULACI√ìN ====================
        async function iniciarSimulacion() {
            const numCamiones = parseInt(document.getElementById('numCamiones').value);
            const capacidad = parseInt(document.getElementById('capacidadCamion').value);
            const numClientes = parseInt(document.getElementById('numClientes')?.value || prediccionesActuales.length || 50);
            const estadoDiv = document.getElementById('estadoSimulacion');
            
            estadoDiv.innerHTML = '<div class="alert alert-info loading">Inicializando simulaci√≥n MAS...</div>';
            
            try {
                const response = await fetch('/api/mas/simular', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        num_camiones: numCamiones,
                        capacidad_camion_kg: capacidad,
                        num_clientes: numClientes,
                        usar_predicciones_lstm: prediccionesActuales.length > 0
                    })
                });
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                // ACTUALIZAR MARCADORES DE BASE Y VERTEDERO (Si el backend env√≠a nuevas coords)
                if (data.coordenadas_depot) {
                    vertederoMarker.setLatLng([data.coordenadas_depot.lat, data.coordenadas_depot.lon]);
                }

                if (data.coordenadas_base) {
                    baseMarker.setLatLng([data.coordenadas_base.lat, data.coordenadas_base.lon]);
                }
                
                simulacionId = data.simulacion_id;
                
                estadoDiv.innerHTML = `<div class="alert alert-success">
                    <strong>Simulaci√≥n iniciada!</strong><br>
                    <small>ID: ${simulacionId}</small><br>
                    <small>${data.num_clientes_reales || 0} puntos a recolectar</small>
                </div>`;
                
                document.getElementById('btnIniciar').disabled = true;
                document.getElementById('btnDetener').disabled = false;
                document.getElementById('btnGuardar').disabled = false;
                
                // Sincronizar IDs del backend con los marcadores
                if (data.clientes) {
                    console.log("üîÑ Sincronizando IDs de clientes con backend...");
                    const nuevosMarcadores = {};
                    // Convertir array actual a array para b√∫squeda
                    const marcadoresArray = Array.isArray(marcadoresPuntos) ? marcadoresPuntos : Object.values(marcadoresPuntos);
                    
                    data.clientes.forEach(clienteBackend => {
                        // Buscar marcador por nombre (asumiendo nombres √∫nicos)
                        // FIX: B√∫squeda robusta ignorando may√∫sculas/espacios
                        const nombreBackend = String(clienteBackend.nombre).trim().toLowerCase();
                        const marker = marcadoresArray.find(m => String(m.options.nombre).trim().toLowerCase() === nombreBackend);
                        
                        if (marker) {
                            // BLINDAJE DE TIPOS FRONTEND
                            let idLimpio = String(clienteBackend.id).trim();
                            
                            marker.options.custom_id = idLimpio;
                            nuevosMarcadores[idLimpio] = marker;
                            
                            // Actualizar popup con ID real
                            const popup = marker.getPopup().getContent();
                            if (popup) {
                                marker.setPopupContent(popup.replace(/ID: \d+/, `ID: ${idLimpio}`));
                            }
                        }
                    });
                    // Reemplazar array con objeto indexado por ID para acceso O(1)
                    marcadoresPuntos = nuevosMarcadores; 
                    console.log(`‚úÖ ${Object.keys(marcadoresPuntos).length} marcadores sincronizados.`);
                }

                // Iniciar actualizaci√≥n autom√°tica
                iniciarActualizacionAutomatica();
                
            } catch (error) {
                console.error('Error:', error);
                estadoDiv.innerHTML = `<div class="alert alert-warning">
                    <strong>Error:</strong> ${error.message}
                </div>`;
            }
        }

        // ==================== FUNCI√ìN: GUARDAR SIMULACI√ìN ====================
        async function guardarSimulacion() {
            if (!simulacionId) return;
            
            const btn = document.getElementById('btnGuardar');
            const originalText = btn.innerHTML;
            btn.disabled = true;
            btn.innerHTML = 'üíæ Guardando...';
            
            try {
                const response = await fetch(`/api/mas/simulacion/${simulacionId}/guardar`, {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    alert(`‚úÖ ${data.mensaje}`);
                } else {
                    throw new Error(data.detail || 'Error al guardar');
                }
            } catch (error) {
                console.error('Error guardando:', error);
                alert(`‚ùå Error: ${error.message}`);
            } finally {
                btn.disabled = false;
                btn.innerHTML = originalText;
            }
        }
        
        // ==================== FUNCI√ìN: INICIAR ACTUALIZACI√ìN AUTOM√ÅTICA ====================
        async function iniciarActualizacionAutomatica() {
            if (timeoutId) clearTimeout(timeoutId);
            if (intervalId) clearInterval(intervalId);
            
            console.log('üöÄ Iniciando simulaci√≥n con animaci√≥n siguiendo calles OSRM');
            
            // FIX: Obtener estado inicial (t=0) ANTES de ejecutar el primer paso
            // Esto asegura que los camiones aparezcan en la Base y tracen la l√≠nea desde ah√≠
            try {
                const debugDiv = document.getElementById('debugInfo') || crearDebugPanel();
                debugDiv.innerHTML = `üì• Obteniendo estado inicial...`;
                
                const estadoResponse = await fetch(`/api/mas/simulacion/${simulacionId}/estado`);
                if (estadoResponse.ok) {
                    const data = await estadoResponse.json();
                    console.log("üìç Estado inicial cargado (Camiones en Base)");
                    actualizarVisualizacion(data);
                }
            } catch (e) {
                console.error("Error cargando estado inicial:", e);
            }

            console.log('üîÑ Ciclo de actualizaci√≥n secuencial activado');
            
            // Iniciar el ciclo
            ejecutarCicloSimulacion();
        }

        // ==================== FUNCI√ìN: ACTUALIZACI√ìN AUTOM√ÅTICA ROBUSTA ====================
        async function ejecutarCicloSimulacion() {
            if (!simulacionId) return;
            if (isFetching) return; // Evitar solapamiento
            
            isFetching = true;
            const debugDiv = document.getElementById('debugInfo') || crearDebugPanel();
            
            try {
                debugDiv.innerHTML = `üîÑ Solicitando paso... (SimID: ${simulacionId})`;
                debugDiv.style.color = '#ffff00'; // Amarillo procesando
                
                // 1. EJECUTAR PASO
                const controller = new AbortController();
                // Aumentar timeout a 120s para evitar abortos por lentitud de OSRM
                const timeoutIdFetch = setTimeout(() => controller.abort(), 120000); 
                
                const pasoResponse = await fetch(`/api/mas/simulacion/${simulacionId}/paso`, { 
                    method: 'POST',
                    signal: controller.signal
                });
                clearTimeout(timeoutIdFetch);
                
                // MANEJO DE ERRORES CR√çTICOS (404 = Simulaci√≥n perdida por reinicio)
                if (pasoResponse.status === 404) {
                    throw new Error("SIMULACION_PERDIDA");
                }
                
                if (!pasoResponse.ok) {
                    throw new Error(`Error HTTP: ${pasoResponse.status}`);
                }
                
                // PROCESAR EVENTOS DE PASO (NUEVO: Para ver negociaciones)
                const pasoData = await pasoResponse.json();
                if (pasoData.eventos && pasoData.eventos.length > 0) {
                    procesarEventos(pasoData.eventos);
                }
                
                // 2. OBTENER ESTADO ACTUALIZADO
                debugDiv.innerHTML = `üì• Obteniendo estado...`;
                const estadoResponse = await fetch(`/api/mas/simulacion/${simulacionId}/estado`);
                
                if (estadoResponse.status === 404) throw new Error("SIMULACION_PERDIDA");
                
                const data = await estadoResponse.json();
                
                // 3. ACTUALIZAR VISUALIZACI√ìN
                debugDiv.innerHTML = `üé® Renderizando (Paso ${data.paso})`;
                debugDiv.style.color = '#00ff00'; // Verde √©xito
                
                actualizarVisualizacion(data);
                
                // Verificar si termin√≥
                if (!data.activa) {
                    console.log('üõë Simulaci√≥n terminada por el servidor');
                    debugDiv.innerHTML = `üèÅ Simulaci√≥n Finalizada`;
                    detenerSimulacion();
                    return;
                }
                
                // 4. SIGUIENTE CICLO (Intervalo corto para minimizar espera entre pasos)
                timeoutId = setTimeout(ejecutarCicloSimulacion, 100); 
                
            } catch (error) {
                console.error('‚ùå Error en ciclo:', error);
                
                if (error.message === "SIMULACION_PERDIDA" || error.message.includes("404")) {
                    debugDiv.innerHTML = `‚ö†Ô∏è SERVIDOR REINICIADO. Por favor inicia de nuevo.`;
                    debugDiv.style.color = '#ff0000';
                    alert("La conexi√≥n con la simulaci√≥n se perdi√≥ (posiblemente el servidor se reinici√≥). Por favor, haz clic en 'Iniciar Simulaci√≥n' nuevamente.");
                    detenerSimulacion();
                } else {
                    debugDiv.innerHTML = `‚ùå Error: ${error.message}. Reintentando...`;
                    timeoutId = setTimeout(ejecutarCicloSimulacion, 5000);
                }
            } finally {
                isFetching = false;
            }
        }

        // ==================== FUNCI√ìN: PROCESAR EVENTOS (NEGOCIACI√ìN + RECOGIDA) ====================
        function procesarEventos(eventos) {
            const bitacora = document.getElementById('bitacoraMensajes');
            if (bitacora.children[0]?.tagName === 'P') bitacora.innerHTML = ''; // Remove "Esperando..."

            eventos.forEach(evento => {
                let msgHTML = '';
                let estiloBorde = '';
                
                if (evento.tipo === 'negociacion') {
                    mostrarToast(`ü§ù ${evento.mensaje}`, 'negociacion');
                    msgHTML = `<span style="color:#f1c40f">‚òÖ</span> <b>[Negociaci√≥n]</b> ${evento.mensaje}`;
                    estiloBorde = 'border-left: 3px solid #f1c40f;';
                    
                    // L√≠nea visual temporal
                    if (marcadoresCamiones[evento.origen_id] && marcadoresCamiones[evento.destino_id]) {
                        const p1 = marcadoresCamiones[evento.origen_id].getLatLng();
                        const p2 = marcadoresCamiones[evento.destino_id].getLatLng();
                        const linea = L.polyline([p1, p2], { color: '#f1c40f', weight: 4, dashArray: '10, 10', opacity: 0.8 }).addTo(map);
                        setTimeout(() => map.removeLayer(linea), 2000);
                    }
                } 
                else if (evento.tipo === 'conflicto') {
                    const datos = evento.datos || {};
                    msgHTML = `<span style="color:#e74c3c">‚ö°</span> <b>[Conflicto]</b> ${datos.mensaje || 'Conflicto detectado'}`;
                    estiloBorde = 'border-left: 3px solid #e74c3c;';
                }
                else if (evento.tipo === 'recogida') {
                    const datos = evento.datos || {};
                    msgHTML = `<span style="color:#2ecc71">‚úì</span> <b>[Recogida]</b> Cami√≥n ${evento.camion_id} recogi√≥ ${datos.residuos_kg?.toFixed(1) || '?'}kg en Cliente ${datos.cliente_id}`;
                    estiloBorde = 'border-left: 3px solid #2ecc71;';
                }
                else if (evento.tipo === 'retorno') {
                    const datos = evento.datos || {};
                    msgHTML = `<span style="color:#3498db">‚ü≤</span> <b>[Retorno]</b> Cami√≥n ${evento.camion_id} descarg√≥ ${datos.carga_descargada?.toFixed(1) || '?'}kg en Depot`;
                    estiloBorde = 'border-left: 3px solid #3498db;';
                }

                if (msgHTML) {
                    const msg = document.createElement('div');
                    msg.style.cssText = `margin-bottom: 4px; padding: 6px; background: white; border-radius: 4px; font-size: 11px; box-shadow: 0 1px 2px rgba(0,0,0,0.05); ${estiloBorde}`;
                    msg.innerHTML = msgHTML;
                    bitacora.prepend(msg); // Lo m√°s nuevo arriba
                }
            });
        }

        function mostrarToast(mensaje, tipo = 'info') {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast ${tipo}`;
            toast.innerHTML = mensaje;
            container.appendChild(toast);
            
            // Eliminar del DOM despu√©s de la animaci√≥n (5s)
            setTimeout(() => {
                if (toast.parentNode) toast.parentNode.removeChild(toast);
            }, 5000);
        }

        // ==================== FUNCI√ìN: ACTUALIZAR VISUALIZACI√ìN (DEBUGGEADA) ====================
        function actualizarVisualizacion(data) {
            console.log("üìä Datos recibidos:", data); // LOG PARA VERIFICAR DATOS
            
            // 1. Actualizar Estad√≠sticas
            const stats = data.estadisticas || {};
            
            // Usar optional chaining y valores por defecto para evitar fallos
            const kg = (stats.total_residuos_recolectados || 0).toFixed(0);
            const servidos = stats.clientes_servidos || 0;
            const totales = stats.clientes_totales || 0;
            
            // Calcular tiempo total (HH:MM)
            const tiempoMin = stats.tiempo_total_estimado || 0;
            const horas = Math.floor(tiempoMin / 60);
            const minutos = Math.floor(tiempoMin % 60);
            const tiempoStr = `${horas.toString().padStart(2, '0')}:${minutos.toString().padStart(2, '0')}`;
            
            const paso = data.paso || 0;
            
            // Actualizar DOM
            document.getElementById('kgRecolectados').textContent = kg;
            document.getElementById('puntosServidos').textContent = `${servidos}/${totales}`;
            document.getElementById('tiempoTotal').textContent = tiempoStr;
            document.getElementById('paso').textContent = paso;
            
            // 1.5 Actualizar Lista de Camiones (NUEVO)
            const listaCamionesDiv = document.getElementById('listaCamiones');
            listaCamionesDiv.innerHTML = ''; // Limpiar lista anterior
            
            data.camiones.forEach((camion, idx) => {
                const item = document.createElement('div');
                item.className = 'truck-item';
                item.style.borderLeftColor = camion.color || '#3498db';
                
                // Valores seguros para evitar crash si el backend env√≠a null/undefined
                const carga = (camion.carga_actual || 0);
                const capacidad = (camion.capacidad_total || camion.capacidad_kg || 3500);
                
                // Calcular porcentaje din√°micamente si no viene o es 0
                let porcentaje = (camion.porcentaje_carga || 0);
                if (porcentaje === 0 && carga > 0) {
                    porcentaje = (carga / capacidad) * 100;
                }
                
                item.innerHTML = `
                    <div style="display:flex; justify-content:space-between;">
                        <strong>Cami√≥n ${idx + 1}</strong>
                        <span style="font-weight:bold;">${porcentaje.toFixed(1)}%</span>
                    </div>
                    <div style="background:#eee; height:5px; border-radius:3px; margin-top:5px;">
                        <div style="background:${camion.color || '#3498db'}; width:${porcentaje}%; height:100%; border-radius:3px;"></div>
                    </div>
                    <small>${camion.activo ? 'En ruta' : 'Inactivo'} | ${carga.toFixed(0)}/${capacidad} kg</small>
                `;
                listaCamionesDiv.appendChild(item);
            });

            // 2. Actualizar Mapa (Camiones)
            lineasRutas.forEach(l => map.removeLayer(l));
            lineasRutas = [];
            
            data.camiones.forEach((camion, idx) => {
                const nuevaPos = L.latLng(camion.posicion.lat, camion.posicion.lon);
                
                // Rastro
                if (ultimaPosicionCamiones[idx]) {
                    const posAnterior = ultimaPosicionCamiones[idx];
                    if (map.distance(posAnterior, nuevaPos) > 5) {
                        const esFallback = camion.es_fallback;
                        
                        // FIX: Usar geometr√≠a real para el rastro si existe
                        let puntosRastro = [posAnterior, nuevaPos];
                        if (camion.geometria_actual && camion.geometria_actual.length > 1) {
                            puntosRastro = camion.geometria_actual;
                        }

                        const rastro = L.polyline(puntosRastro, {
                            color: esFallback ? '#ff0000' : (camion.color || '#e74c3c'),
                            weight: esFallback ? 2 : 3, 
                            opacity: 0.6,
                            dashArray: esFallback ? '5, 10' : null
                        }).addTo(map);
                        
                        // Guardar referencia para limpiar si es necesario (opcional)
                        // rastrosCamiones.push(rastro); 
                    }
                }
                ultimaPosicionCamiones[idx] = nuevaPos;
                
                // Marcador
                if (marcadoresCamiones[idx]) {
                    // Animar (Velocidad suave: 800ms)
                    const geometria = camion.geometria_actual || camion.ruta_geometria;
                    animarMovimiento(marcadoresCamiones[idx], marcadoresCamiones[idx].getLatLng(), nuevaPos, 800, geometria);
                    
                    // Popup
                    marcadoresCamiones[idx].setPopupContent(`
                        <b>Cami√≥n ${idx + 1}</b><br>
                        Carga: ${camion.carga_actual.toFixed(0)} kg
                    `);
                } else {
                    // Crear
                    const marker = L.marker(nuevaPos, {
                        icon: L.divIcon({
                            className: 'truck-icon',
                            html: `<div style="background: ${camion.color}; color: white; width: 30px; height: 30px; border-radius: 50%; display: flex; justify-content: center; align-items: center; border: 2px solid white;">${idx+1}</div>`
                        })
                    }).addTo(map);
                    marcadoresCamiones[idx] = marker;
                }
                
                // Ruta futura (l√≠nea punteada)
                if (camion.ruta_geometria && camion.ruta_geometria.length > 0) {
                    // Asegurar que el trazo comience desde la posici√≥n actual del cami√≥n
                    let rutaVisual = [...camion.ruta_geometria];
                    const posActual = [camion.posicion.lat, camion.posicion.lon];
                    
                    // Si el primer punto est√° lejos de la posici√≥n actual, insertar posici√≥n actual
                    const primerPunto = rutaVisual[0];
                    if (Math.abs(primerPunto[0] - posActual[0]) > 0.0001 || Math.abs(primerPunto[1] - posActual[1]) > 0.0001) {
                        rutaVisual.unshift(posActual);
                    }

                     const linea = L.polyline(rutaVisual, {
                        color: camion.color, weight: 2, dashArray: '5, 10', opacity: 0.5
                    }).addTo(map);
                    lineasRutas.push(linea);
                }
            });
            
            // 3. Actualizar Clientes (Servidos) - L√≥gica Robusta y Agn√≥stica al Tipo
            if (data.clientes_servidos_ids && Array.isArray(data.clientes_servidos_ids)) {
                data.clientes_servidos_ids.forEach(rawId => {
                    // 1. Normalizaci√≥n del ID entrante (String y Trim)
                    const idObjetivo = String(rawId).trim();
                    const idObjetivoLower = idObjetivo.toLowerCase();
                    
                    // 2. B√∫squeda del marcador (Estrategia "Busca hasta encontrar")
                    let marker = null;
                    const listaMarcadores = Array.isArray(marcadoresPuntos) ? marcadoresPuntos : Object.values(marcadoresPuntos);
                    
                    // Estrategia A: B√∫squeda Directa en Diccionario (si es objeto)
                    if (!Array.isArray(marcadoresPuntos) && marcadoresPuntos[idObjetivo]) {
                        marker = marcadoresPuntos[idObjetivo];
                    }
                    
                    // Estrategia B: B√∫squeda Iterativa (Funciona para Array y Objeto)
                    if (!marker) {
                        // B.1: Por custom_id exacto (string vs string)
                        marker = listaMarcadores.find(m => String(m.options.custom_id).trim() === idObjetivo);
                        
                        // B.2: Por nombre (si el ID falla, tal vez el nombre coincida con el ID o viceversa)
                        if (!marker) {
                             marker = listaMarcadores.find(m => String(m.options.nombre).trim() === idObjetivo);
                        }

                        // B.3: B√∫squeda Desesperada (Ignorar may√∫sculas, espacios internos, tipos)
                        if (!marker) {
                            marker = listaMarcadores.find(m => {
                                const mId = String(m.options.custom_id).trim().toLowerCase();
                                const mNombre = String(m.options.nombre).trim().toLowerCase();
                                return mId === idObjetivoLower || mNombre === idObjetivoLower || 
                                       mId.includes(idObjetivoLower) || idObjetivoLower.includes(mId);
                            });
                        }
                    }

                    // 3. Validaci√≥n de Existencia y Actualizaci√≥n
                    if (marker) {
                        // Verificar si ya estaba marcado para no repetir operaciones (Optimizaci√≥n)
                        if (marker.options.fillColor !== '#ecf0f1') {
                            // CAMBIO VISUAL: Gris (Recogido)
                            marker.setStyle({
                                fillColor: '#ecf0f1', 
                                color: '#bdc3c7', 
                                fillOpacity: 0.4,
                                weight: 1,
                                radius: 6
                            });
                            
                            // Actualizar popup indicando estado
                            const popupContent = marker.getPopup().getContent();
                            if (!popupContent.includes("(RECOLECTADO)")) {
                                marker.setPopupContent(popupContent.replace("</h4>", " <span style='color:gray; font-size:0.8em'>(RECOLECTADO)</span></h4>"));
                            }
                        }
                    }
                });
            } else if (data.clientes_servidos_coords) {
                // Fallback para compatibilidad antigua
                data.clientes_servidos_ids.forEach(id => {
                    if (marcadoresPuntos[id]) {
                        marcadoresPuntos[id].setStyle({
                            fillColor: '#bdc3c7', color: '#7f8c8d', fillOpacity: 0.2
                        });
                    }
                });
            }
        }
        
        // ==================== FUNCI√ìN: ANIMAR MOVIMIENTO SIGUIENDO GEOMETR√çA OSRM ====================
        function animarMovimiento(marker, desde, hacia, duracion, geometria = null) {
            // Si hay geometr√≠a OSRM, animar siguiendo cada punto de la ruta real
            // Se acepta length >= 2 para incluir l√≠neas rectas generadas por fallback
            if (geometria && geometria.length >= 2) {
                // console.log(`üöó Animando con ${geometria.length} puntos`);
                
                const puntosRuta = geometria;
                
                // Si son pocos puntos (ej. l√≠nea recta), usar interpolaci√≥n lineal para suavidad
                if (puntosRuta.length <= 2) {
                    animarMovimientoLineal(marker, desde, hacia, duracion);
                    return;
                }
                
                // Animar punto por punto siguiendo la geometr√≠a compleja
                const tiempoPorPunto = duracion / puntosRuta.length;
                let indicePunto = 0;
                
                const timer = setInterval(() => {
                    if (indicePunto >= puntosRuta.length) {
                        clearInterval(timer);
                        marker.setLatLng(hacia); // Asegurar posici√≥n final
                        return;
                    }
                    
                    const punto = puntosRuta[indicePunto];
                    marker.setLatLng([punto[0], punto[1]]);
                    indicePunto++;
                }, tiempoPorPunto);
            } else {
                // Sin geometr√≠a: animaci√≥n lineal tradicional
                console.warn("‚ö†Ô∏è Sin geometr√≠a v√°lida, usando animaci√≥n lineal");
                animarMovimientoLineal(marker, desde, hacia, duracion);
            }
        }
        
        // Animaci√≥n lineal (fallback cuando no hay geometr√≠a)
        function animarMovimientoLineal(marker, desde, hacia, duracion) {
            const pasos = 30;
            const deltaLat = (hacia.lat - desde.lat) / pasos;
            const deltaLng = (hacia.lng - desde.lng) / pasos;
            const intervalo = duracion / pasos;
            
            let paso = 0;
            const timer = setInterval(() => {
                if (paso >= pasos) {
                    clearInterval(timer);
                    marker.setLatLng(hacia);
                    return;
                }
                
                const lat = desde.lat + (deltaLat * paso);
                const lng = desde.lng + (deltaLng * paso);
                marker.setLatLng([lat, lng]);
                paso++;
            }, intervalo);
        }
        
        // ==================== FUNCI√ìN: DETENER SIMULACI√ìN ====================
        function detenerSimulacion() {
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
            }
            if (timeoutId) {
                clearTimeout(timeoutId);
                timeoutId = null;
            }
            
            if (simulacionId) {
                fetch(`/api/mas/simulacion/${simulacionId}/detener`, { method: 'POST' });
            }
            
            document.getElementById('btnIniciar').disabled = false;
            document.getElementById('btnDetener').disabled = true;
            document.getElementById('estadoSimulacion').innerHTML = '<div class="alert alert-info">Simulaci√≥n detenida</div>';
        }
        
        // ==================== FUNCIONES AUXILIARES ====================
        function crearDebugPanel() {
            const div = document.createElement('div');
            div.id = 'debugInfo';
            div.style.position = 'fixed';
            div.style.bottom = '10px';
            div.style.right = '10px';
            div.style.background = 'rgba(0,0,0,0.8)';
            div.style.color = '#00ff00';
            div.style.padding = '10px';
            div.style.borderRadius = '5px';
            div.style.fontFamily = 'monospace';
            div.style.fontSize = '12px';
            div.style.zIndex = '9999';
            div.style.pointerEvents = 'none';
            div.innerHTML = 'Esperando inicio...';
            document.body.appendChild(div);
            return div;
        }

        function getColorPorDemanda(kg) {
            if (kg < 80) return '#2ecc71';
            if (kg < 120) return '#f39c12';
            return '#e74c3c';
        }
        
        function getRadioPorDemanda(kg) {
            if (kg < 80) return 6;
            if (kg < 120) return 9;
            return 12;
        }
    </script>
</body>
</html>
